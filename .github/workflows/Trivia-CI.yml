# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs

name: NEURONE-Trivia CI-CD

on:
  # workflow_dispatch:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  #Dependencies Version
  NODE_VERSION: "16.14.1"
  ANGULAR_VERSION: "16.2.10"

  #SSH keys of Autorized Host to connect to pre-production server later
  SSH_PUBLIC_KEY: ${{ secrets.SSH_PUBLIC_KEY }} #Clave publica de la maquina para conectarse al servidor
  SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY}} #Clave privada de la maquina para conectarse al servidor
  PASSPHRASE_SSH_PRIVATE_KEY: "frase-random"

  #NEURONEGM Database information
  NEURONEGM_DATABASE: "neuronegm"
  NEURONEGM_DATABASE_USER: "neuroneAdmin"
  NEURONEGM_DATABASE_PASSWORD: ${{ secrets.NEURONEGM_DATABASE_PASSWORD }}

  NEURONEGM_REPOSITORY: "trabajo-titulacion-neurone/modulo-neurone-gm"
  NEURONEGM_REPOSITORY_FOLDER_NAME: "neurone-gm"
  NEURONEGM_SERVER_DIRECTORY: "./neurone-gm/Server"

  #Trivia Data
  TRIVIA_REPOSITORY_FOLDER_NAME: "trivia"
  TRIVIA_CLIENT_DIRECTORY: "./trivia/Client"
  TRIVIA_SERVER_DIRECTORY: "./trivia/Server"


jobs:
  build:

    runs-on: ubuntu-22.04

    strategy:
      matrix:
        node-version: [16.14.1]
        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/

    steps:
    
    #Generate a pair of SSH keys that will be replaced later by the environment variable keys
    - name: ssh-keygen
      run: ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N ''

    - name: Copy ssh key of environment variables in local machine
      run: |
        echo "${{ env.SSH_PUBLIC_KEY }}" > ~/.ssh/id_rsa.pub
        echo "${{ env.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        ssh-keygen -p -P "" -N "${{ env.PASSPHRASE_SSH_PRIVATE_KEY }}" -f ~/.ssh/id_rsa
  
        #chmod 600 ~/.ssh/id_rsa    

        
    - name: Cloning Trivia Repository
      uses: actions/checkout@v3
      with:
        path: ${{ env.TRIVIA_REPOSITORY_FOLDER_NAME }} 
        
    # - name: Cloning Neurone-gm repository
    #   uses: actions/checkout@v3
    #   with:
    #     repository: ${{ env.NEURONEGM_REPOSITORY }}
    #     # token: 
    #     path: ${{ env.NEURONEGM_REPOSITORY_FOLDER_NAME }}

    
    # - name: Use Node.js ${{ matrix.node-version }}
    #   uses: actions/setup-node@v3
    #   with:
    #     # node-version: ${{ matrix.node-version }}
    #     node-version: ${{ env.NODE_VERSION }}
    #     cache: 'npm'
    #     cache-dependency-path: '${{ env.TRIVIA_CLIENT_DIRECTORY }}/package-lock.json'
      
    # - name: Run MongoDB with Docker
    #   run: docker run -d --name mongo-for-tests -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=${{ env.NEURONEGM_DATABASE_USER}} -e MONGO_INITDB_ROOT_PASSWORD=${{ env.NEURONEGM_DATABASE_PASSWORD }} -e MONGO_INITDB_DATABASE=${{ env.NEURONEGM_DATABASE }} mongo:latest
   
    # - name: Install pm2 globally
    #   run: npm install -g pm2
      
    # - name: Install http-server globally (OPTIONAL)
    #   run: npm install -g http-server

    # - name: Install Angular globally
    #   run: npm install -g @angular/cli@${{env.ANGULAR_VERSION}}
        
    # - name: Run Neurone-gm Server with pm2
    #   working-directory: ${{ env.NEURONEGM_SERVER_DIRECTORY }}
    #   run: |
    #     npm install
    #     # npm test
    #     pm2 start app.js --name neurone-gm
    #     # timeout 2s pm2 logs

    # - name: Run Trivia Server with pm2
    #   working-directory: ${{ env.TRIVIA_SERVER_DIRECTORY }}
    #   run: |
    #     npm install
    #     # npm test
    #     pm2 start app.js --name neurone-trivia
    #     # timeout 2s pm2 logs

    # - name: Build Trivia Frontend
    #   working-directory: ${{ env.TRIVIA_CLIENT_DIRECTORY }}
    #   run: |
    #     ls
    #     npm install
    #     ng build --prod --output-path ../Server/public

    # - name: Run Frontend (OPCIONAL)
    #   working-directory: ./trivia/Server/public
    #   run: nohup http-server -p 8080 &




      

    - name: crear archivo para enviar
      run: |
        touch archivo.txt
        ls -a
        cd .ssh/
        ls
    

    - name: ssh key with passphrase
      uses: appleboy/scp-action@v0.1.4
      with:
        host: 157.245.130.194
        username: root
        #key: ${{ env.SSH_PRIVATE_KEY }}
        key_path: ~/.ssh/id_rsa
        passphrase: ${{ env.PASSPHRASE_SSH_PRIVATE_KEY }}
        port: 22
        source: "./trivia"
        target: "./escritorio"
































    

    # - name: Install doctl
    #   uses: digitalocean/action-doctl@v2
    #   with:
    #     token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
        

    # #Se busca con doctl si existe o no una clave con el nombre $SSH_KEY_NAME en la cuenta de digitalocean, en caso de que no, la crea subiendo la clave publica $SSH_PUBLIC_KEY.
    # - name: Find or upload ssh key for digitalocean account
    #   run: |
    #     # Si la clave SSH con nombre 'key-droplet' no existe, se crea.
    #     if ! doctl compute ssh-key list --format "Name" | grep -q $SSH_KEY_NAME; then
    #       echo "La clave SSH $SSH_KEY_NAME no se encontró. Creando nueva clave SSH..."
    #       doctl compute ssh-key create $SSH_KEY_NAME --public-key "$SSH_PUBLIC_KEY"
    #       echo "Clave SSH creada con éxito"
    #     #Sino, se imprime un mensaje por pantalla
    #     else
    #       echo "La clave SSH $SSH_KEY_NAME ya existe."
    #     fi
    #     #Se obtiene el ID de la clave para así agregarla al listado de claves permitidas del droplet a crear
    #     echo "SSH_KEY_ID=$(doctl compute ssh-key list --format "ID,Name" | grep $SSH_KEY_NAME | awk '{print $1}')" >> "$GITHUB_ENV"
        
    # - name: print SSH_KEY_ID (BORRAR)
    #   run: echo "la key es $SSH_KEY_ID y el nombre de la clave es $SSH_KEY_NAME"
      
      
      
    # #Se verifica si el droplet o VPS a crear ya existe (se busca por nombre)
    # - name: Check if the Droplet exists
    #   run: |
    #     # Se obtiene el ID de un Droplet existente con nombre $DROPLET_NAME utilizando doctl y filtrando la salida con grep y awk.
    #     droplet_id=$(doctl compute droplet list --format "ID,Name" --no-header | grep $DROPLET_NAME | awk '{print $1}')
        
    #     if [[ -z $droplet_id ]]; then
    #       echo "Droplet does not exist" # Si el Droplet no existe, se imprime un mensaje
    #       echo "create_droplet=true" >> $GITHUB_ENV # Se establece una salida personalizada "create_droplet" en "true"
    #     else
    #       echo "Droplet already exists" # Si el Droplet ya existe, se imprime un mensaje
    #       echo "create_droplet=false" >> $GITHUB_ENV # Se establece una salida personalizada "create_droplet" en "false"
    #     fi
   
    # # Si el droplet no existe, se crea.
    # # Este paso se ejecutará solo si la salida personalizada "create_droplet" del paso anterior es 'true'
    # - name: Create Droplet if it does not exist
    #   if: env.create_droplet == 'true'
    #   run: |
    #     #Se crea un nuevo droplet con las siguientes caracteristicas
    #     #Nombre: droplet-actions-neurone
    #     #SO: Ubuntu 22.04 x64 LTS
    #     #Region: Nueva York C1
    #     doctl compute droplet create $DROPLET_NAME --image ubuntu-22-04-x64 --size s-1vcpu-1gb --region nyc1 --ssh-keys $SSH_KEY_ID --wait

    # #Se obtiene la IP del droplet con nombre DROPLET_NAME y se guarda en la variable de entorno DROPLET_IPV4
    # - name: Get Public IPv4 address
    #   run: | 
    #     #Se crea el droplet
    #     echo "DROPLET_IPV4=$(doctl compute droplet list --format "Name,Public IPv4" --no-header | grep $DROPLET_NAME | awk '{print $2}')" >> "$GITHUB_ENV"
        
    # - name: Testing SSH connection
    #   run: |
    #     #Se verifica si el droplet ya se encuentra activo realizando una conexion ssh de prueba
    #     for i in {1..3}; do
    #       echo "Intento $i de conexión SSH"
    #       if ssh -o "StrictHostKeyChecking no" -i "$SSH_PRIVATE_KEY" root@$DROPLET_IPV4 'echo "Conexión exitosa"'; then
    #         echo "Conexión exitosa"
    #         break
    #       fi
    #       echo "Conexión rechazada. Esperando y reintentando..."
    #       sleep 10  # Espera 10 segundos entre reintentos
    #     done
    #     if [ $i -eq 4 ]; then
    #       echo "Conexión SSH fallida después de 3 intentos."
    #       exit 1
    #     fi
        
    # #Se realiza la conexión SSH con el servidor remoto creado
    # - name: SSH Connection with Server
    #   uses: appleboy/ssh-action@v1.0.0
    #   with:
    #     host: ${{ env.DROPLET_IPV4 }}
    #     username: root
    #     key: ${{ env.SSH_PRIVATE_KEY }}
    #     port: 22
    #     script: |
    #       echo "hola mundo estoy dentro del servidor"
    #       ls
    #       mkdir CarpetaSSH
 

